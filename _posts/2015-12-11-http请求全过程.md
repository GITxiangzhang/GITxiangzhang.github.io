---
title: http请求过程以及三次握手

---

#### TCP协议采用三次握手建立链接与断开链接

>TCP/IP协议中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。
 TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。
 通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。

TCP协议提供可靠的连接服务，建立TCP连接的过程需要进行三次信息交换，通常称为“三次握手”，示意图如下：

 ![Image]({{ site.baseurl }}/images/三次握手.jpg)

图中Seq代表TCP段首部中的“序号（Sequence Number）”：是TCP段所发送的数据部分第一个字节的序号。在TCP传送的数据流中，每一个字节都有一个序号。建立连接时，
发送方将初始序号（Initial Sequence Number, ISN）填写到第一个发送的TCP段序号中。

图中Ack代表TCP段首部中的“确认号”：是期望收到对方下次发送的数据的第一个字节的序号，
也就是期望收到的下一个TCP段的首部中的序号，等于已经成功收到的TCP段的最后一个字节序号加1。
确认号在ACK标志为1时有意义，除了主动发起连接的第一个TCP段不设置ACK标志外，其后发送的TCP段都会设置ACK标志。

三次握手的具体过程阐述如下：

1. 客户端主动与服务器联系，TCP首部控制位中的SYN设置为1，发送带有SYN的TCP段，并把初始序号告诉对方。

2. 服务器端收到带有SYN的报文，记录客户端的初始序号，选择自己的初始序号，设置控制位中的SYN和ACK。因为SYN占用一个序号，所以确认序号设置为客户端的初始序号加1，对客户端的SYN进行确认。

3. 服务器端的报文到达客户端，客户端设置ACK控制位，并把确认号设为服务器的初始序号加1，以确认服务器的SYN报文段，这个报文只是确认信息，告诉服务器已经成功建立了连接。

至此“三次握手”建立连接完成。在TCP连接中，每台主机会创建一个TCB数据结构，存储与连接有关的数据。


第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的syn（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。




假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。
所以你先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。
当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。
Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。
“Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！

【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？
答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文
----------------------------------

##### http请求过程
>1. 建立TCP连接
在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。
HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。


>2. Web浏览器向Web服务器发送请求命令
一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。

>3. Web浏览器发送请求头信息
浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。

>4. Web服务器应答
客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。

>5. Web服务器发送应答头信息
正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。

>6. Web服务器向浏览器发送数据
Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。

>7. Web服务器关闭TCP连接
一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive
TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。


HTTP请求为https:https://gitxiangzhang.github.io/
当浏览器向Web服务器发出请求时，它向服务器传递了一个数据块，也就是请求信息，

HTTP请求信息由3部分组成：

1、请求方法（GET/POST）、URI、协议/版本

GET https:https://gitxiangzhang.github.io/ HTTP/1.1

以上代码中“GET”代表请求方法，“https:https://gitxiangzhang.github.io/”表示URI，“HTTP/1.1代表协议和协议的版本。

2、请求头(Request Header)


Content-Type  是返回消息中非常重要的内容，表示后面的文档属于什么MIME类型。Content-Type: [type]/[subtype]; parameter。例如最常见的就是text/html，
              它的意思是说返回的内容是文本类型，这个文本又是HTML格式的。原则上浏览器会根据Content-Type来决定如何显示返回的消息体内容

Host  指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回

Accept  浏览器可接受的MIME类型

Accept-Charset  浏览器可接受的字符集

Accept-Encoding 浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间

Accept-Language 浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到

Authorization 授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中

Connection  表示是否需要持久连接。如果Servlet看到这里的值为“Keep- Alive”，或者看到请求使用的是HTTP1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入 ByteArrayOutputStream，然后在正式写出内容之前计算它的大小

Content-Length  表示请求消息正文的长度

Cookie  这是最重要的请求头信息之一

Host  初始URL中的主机和端口

User-Agent 浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用

UA-Pixels，UA-Color，UA-OS，UA-CPU

3、请求正文
请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。

 ![Image]({{ site.baseurl }}/images/request.PNG)


















{% highlight javascript %}
<script type="module" src="foo.js"></script>
{% endhighlight %}
ES6 模块默认异步加载，等同于script标签的defer属性。

ES6 模块也允许内嵌在网页中，其他和ES5一致。


----------------------------------
#### ES6 模块与CommonJS 模块的差异
>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，
再根据这个只读引用，到被加载的那个模块里面去取值。


----------------------------------
#### node 加载
>node有自己的ConmmonJS的模块格式，与es6的module不兼容。

一个模块脚本只要有一行import或export语句，Node 就会认为该脚本为 ES6 模块，否则就为 CommonJS 模块。

ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。


----------------------------------
#### import 加载 CommonJS模块
>import 加载 CommonJS模块，node会把被加载模块的module.exports属性，当做模块的默认输出，等同于export default。（export default 只能有一个啊，所以默认输出最后一个？）

下面是一个CommonJS模块
{% highlight javascript %}
//export-default.js
var PI=3.1415;
function circle(r){
    return PI*r*r;
}
module.exports=circle;
module.exports=PI;
{% endhighlight %}

import 命令加载上面模块，module.exports视为默认输出（export default）。

{% highlight javascript %}
//方法一
import  baz from './export-default';
console.log(baz);//3.1415
//方法二
import * as baz from './export-default';
console.log(baz.default);//baz本身是一个对象，不能当作函数调用或者，只能通过baz.default调用
{% endhighlight %}



----------------------------------
#### require 加载ES6模块
>采用require命令加载 ES6 模块时，ES6 模块的所有输出接口，会成为输入对象的属性。

{% highlight javascript %}
export default function foo() {
    console.log('foo');
};
export var PI=3.1415;
export function circle(r){
    return PI*r*r;
}

var dexport=require('./export-default');
console.log(dexport);
{% endhighlight %}

上面代码中，default接口变成了es_namespace.default属性。另外，由于存在缓存机制，es.js对foo的重新赋值没有在模块外部反映出来。


----------------------------------
#### 循环加载
>a加载b,b加载c,c加载a,两种模块格式CommonJS和ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。

----------------------------------
##### CommonJS模块的循环加载
>require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。
即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。除非手动清除系统缓存
{% highlight javascript %}
{
  id: '...',
  exports: { ... },
  loaded: true,
  ...
}
{% endhighlight %}
上面代码就是Node内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。

CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。


看个栗子：
{% highlight javascript %}
//a.js

exports.done = false;
var b = require('./b.js');
console.log('在 a.js 之中，b.done = %j', b.done);
exports.done = true;
console.log('a.js 执行完毕');
{% endhighlight %}

a.js 先输出一个done 变量，然后加载另一个脚本文件b.js,此时a.js会等待b.js执行完毕再往下执行。

{% highlight javascript %}
//b.js

exports.done = false;
var a = require('./a.js');
console.log('在 b.js 之中，a.done = %j', a.done);
exports.done = true;
console.log('b.js 执行完毕');
{% endhighlight %}

b.js执行到第二行就回去加载 a.js 这时候发生了循环加载 。系统回去 a.js模块对应对象的exports属性取值，可因为a.js 没执行完，只会输出已经执行
的部分。

此时 a.js 只执行了一行
{% highlight javascript %}
exports.done = false;
{% endhighlight %}

对于b.js 来说 他加载a.js 此时a.js只输入了一个done变量，值为false

然后b.js 接着往下执行 等到执行完后 再把执行权交给a.js, a.js继续执行。

所以最后执行结果为：

{% highlight javascript %}

在 b.js 之中，a.done = false
b.js 执行完毕
在 a.js 之中，b.done = true
a.js 执行完毕
在 main.js 之中, a.done=true, b.done=true

{% endhighlight %}

上面代码说明了两件事。
1. 在b.js中 a.js没有执行完，只跑了一行
2. main.js执行到第二行时，不会再次执行b.js，而是输出了缓存的b.js。

由于CommonJS模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。

----------------------------------
##### ES6 模块的循环加载
>ES6 处理“循环加载”与CommonJS有本质的不同。ES6模块是动态引用如果使用import从一个模块加载变量（即import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。

再来看个栗子：

{% highlight javascript %}

// a.js如下
import {bar} from './b.js';
console.log('a.js');
console.log(bar);
export let foo = 'foo';

// b.js
import {foo} from './a.js';
console.log('b.js');
console.log(foo);
export let bar = 'bar';

{% endhighlight %}

上面代码中 a.js 第一行是加载b.js 所以执行b.js 。而b.js 第一行又是加载a.js ，a.js已经开始执行，不会重复执行，会继续往下跑b.js
所以第一行输出是b.js

接着，b.js 要打印 foo 这时a.js 还没执行完，取不到foo 所以是 undfined, b.js执行完。跑a.js

{% highlight javascript %}
b.js
undefined
a.js
bar
{% endhighlight %}


再看一个栗子：

{% highlight javascript %}
// a.js
import {bar} from './b.js';
export function foo() {
  console.log('foo');
  bar();
  console.log('执行完毕');
}
foo();

// b.js
import {foo} from './a.js';
export function bar() {
  console.log('bar');
  if (Math.random() > 0.5) {
    foo();
  }
}
{% endhighlight %}

如果按照 CommonJS规范，上面代码，a加载b ,b又加载a ,这时a没有任何执行结果，输出是null ,对于b来说，foo的值等于null
foo()就应该报错。

但执行结果为：

{% highlight javascript %}
foo
bar
执行完毕
{% endhighlight %}

a.js之所以能够执行，原因就在于ES6加载的变量，都是动态引用其所在的模块。只要引用存在，代码就能执行。（和commonjs不同，引用会执行整个脚本，然后在内存生成一个对象）

















