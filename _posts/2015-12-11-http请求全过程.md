---
title: http请求过程，三次握手，状态码 ，头部信息

---

#### TCP协议采用三次握手建立链接与断开链接

>TCP/IP协议中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。
 TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。
 通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。

TCP协议提供可靠的连接服务，建立TCP连接的过程需要进行三次信息交换，通常称为“三次握手”，示意图如下：

 ![Image]({{ site.baseurl }}/images/三次握手.jpg)

图中Seq代表TCP段首部中的“序号（Sequence Number）”：是TCP段所发送的数据部分第一个字节的序号。在TCP传送的数据流中，每一个字节都有一个序号。建立连接时，
发送方将初始序号（Initial Sequence Number, ISN）填写到第一个发送的TCP段序号中。

图中Ack代表TCP段首部中的“确认号”：是期望收到对方下次发送的数据的第一个字节的序号，
也就是期望收到的下一个TCP段的首部中的序号，等于已经成功收到的TCP段的最后一个字节序号加1。
确认号在ACK标志为1时有意义，除了主动发起连接的第一个TCP段不设置ACK标志外，其后发送的TCP段都会设置ACK标志。

三次握手的具体过程阐述如下：

1. 客户端主动与服务器联系，TCP首部控制位中的SYN设置为1，发送带有SYN的TCP段，并把初始序号告诉对方。

2. 服务器端收到带有SYN的报文，记录客户端的初始序号，选择自己的初始序号，设置控制位中的SYN和ACK。因为SYN占用一个序号，所以确认序号设置为客户端的初始序号加1，对客户端的SYN进行确认。

3. 服务器端的报文到达客户端，客户端设置ACK控制位，并把确认号设为服务器的初始序号加1，以确认服务器的SYN报文段，这个报文只是确认信息，告诉服务器已经成功建立了连接。

至此“三次握手”建立连接完成。在TCP连接中，每台主机会创建一个TCB数据结构，存储与连接有关的数据。


第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

第二次握手：服务器收到syn包，必须确认客户的syn（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。




假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。
所以你先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。
当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。
Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。
“Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！

【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？
答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文

----------------------------------

##### http请求过程
> 1 建立TCP连接
在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。
HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。


> 2 Web浏览器向Web服务器发送请求命令
一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。

> 3 Web浏览器发送请求头信息
浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。

> 4 Web服务器应答
客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。

> 5 Web服务器发送应答头信息
正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。

> 6 Web服务器向浏览器发送数据
Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。

> 7 Web服务器关闭TCP连接
一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive
TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。


HTTP请求为https:https://gitxiangzhang.github.io/
当浏览器向Web服务器发出请求时，它向服务器传递了一个数据块，也就是请求信息，

HTTP请求信息由3部分组成：

1、请求方法（GET/POST）、URI、协议/版本

GET https:https://gitxiangzhang.github.io/ HTTP/1.1

以上代码中“GET”代表请求方法，“https:https://gitxiangzhang.github.io/”表示URI，“HTTP/1.1代表协议和协议的版本。

2、请求头(Request Header)


Content-Type  是返回消息中非常重要的内容，表示后面的文档属于什么MIME类型。Content-Type: [type]/[subtype]; parameter。例如最常见的就是text/html，
              它的意思是说返回的内容是文本类型，这个文本又是HTML格式的。原则上浏览器会根据Content-Type来决定如何显示返回的消息体内容

Host  指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回

Accept  浏览器可接受的MIME类型

Accept-Charset  浏览器可接受的字符集

Accept-Encoding 浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间

Accept-Language 浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到

Authorization 授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中

Connection  表示是否需要持久连接。如果Servlet看到这里的值为“Keep- Alive”，或者看到请求使用的是HTTP1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入 ByteArrayOutputStream，然后在正式写出内容之前计算它的大小

Content-Length  表示请求消息正文的长度

Cookie  这是最重要的请求头信息之一

Host  初始URL中的主机和端口

User-Agent 浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用

UA-Pixels，UA-Color，UA-OS，UA-CPU

3、请求正文
请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。

 ![Image]({{ site.baseurl }}/images/request.PNG)


 ----------------------------------
 #### http 状态码

 ### 临时响应1XX
 100 	Continue   收到客户端请求的初始部分，可继续发送。发送了这个状态码之后服务器在书到请求之后必须进行响应。

 如果客户端向服务器发送一个实体，并且愿意在发送实体之前等待100 continue响应，那么客户端就要发送一个携带值为100 continue的except请求首部。
 如果客户端没有发送实体，就不要发送带有100 continue的expect请求首部，这样会让服务端误以为客户端要发送一个实体。

 101 Switching Protocols    说明服务器正在根据客户端的指定，将协议切换成update 首部所列的协议。

 ### 成功2XX
 200 OK

 201 Created   用于创建服务器对象的请求

 202 Accepted   请求已接受，但服务器还没有对其执行任何动作。

 203 Non-Authoritative Information    文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝

 204 	No Content   请求执行成功，但是没有数据，浏览器不用刷新页面.也不用导向新的页面

 205 Reset Content	 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容

 206 	Partial Content   客户发送了一个带有Range头的GET请求，服务器完成了它

 ### 重定向3XX

 300 Multiple Choices  客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。

 301 Moved Permanently   客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。

 302 Found    类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。

 303 See Other  类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取

 304 Not Modified   客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告 诉客户，原来缓冲的文档还可以继续使用。

 305 Use Proxy  客户请求的文档应该通过Location头所指明的代理服务器提取（HTTP 1.1新）。

 307 Temporary Redirect   和302 （Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时才能重定向。
 由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只 能跟随对GET请求的重定向。（HTTP 1.1新）

 ### 请求错误4XX

 400 Bad Request  请求出现语法错误。

 401 Unauthorized  客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填 写合适的Authorization头后再次发出请求。

 403 Forbidden  资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致

 404 Not Found  无法找到指定位置的资源。这也是一个常用的应答。

 405 Method Not Allowed   请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用

 406 Not Acceptable   指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容

 407 Proxy Authentication Required    类似于401，表示客户必须先经过代理服务器的授权

 408 Request Timeout   在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新）

 409 Conflict  通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功

 410 Gone  所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回410表示文档永久地离开了指定的位置，而 404表示由于未知的原因文档不可用

 411 	Length Required   服务器不能处理请求，除非客户发送一个Content-Length头

 412 Precondition Failed  请求头中指定的一些前提条件失败

 413 Request Entity Too Large  目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头

 414 	Request URI Too Long  URL太长

 ### 服务器错误5XX

 500 	Internal Server Error  服务器遇到了意料不到的情况，不能完成客户的请求。

 501 	Not Implemented  服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。

 502 	Bad Gateway  服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。

 503 	Service Unavailable 服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个 Retry-After头。

 504 Gateway Timeout 由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新）超时

 505 HTTP Version Not Suppo rted 服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新）

