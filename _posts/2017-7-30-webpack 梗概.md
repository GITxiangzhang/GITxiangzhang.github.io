---
title: webpack 梗概

---

#### 现状
>随着互联网发展，现在越来越多的网站已经从网页模式走到了webapp的模式。使用了很多H5,css3,es6等新技术开发更加丰富的功能，现在的网页已经
不单单是满足一个浏览的需求，而是要满足很多应用功能的需求，这就导致我们需要用异步的方式去加载更多的视图，这个过程中势必需要加载更多的
JavaScript代码，这就给前端资源组织带来很大的挑战。

我们知道前端资源是通过增量加载的方式运行到浏览器，如何在开发环境下组织好这些碎片化的代码和资源，保证他们在浏览器快速，优雅的加载和更新
就需要一个模块化系统，这个理想中的模块化系统是前端工程师一直探索的难题。

----------------------------------
#### 模块化系统的演变
1. ##### script 标签

这是最原始的JavaScript文件加载方式。

早期为了解决这些弊端一些复杂的框架会使用命名空间来组织这些模块接口，典型的YUI库。
这个过程https://github.com/seajs/seajs/issues/547这篇博客讲的不错，可以了解。

这种方式暴露显而易见弊端：
* 全局作用域下变量冲突
* 文件只能按照script 标签书写顺序进行加载
* 开发必须主观解决模块间的依赖关系
* 在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪。

2. ##### CommonJS
详情见我的博客 [commonJS规范](https://gitxiangzhang.github.io/xiangzhang.github.io/2016/04/29/CommonJS%E8%A7%84%E8%8C%83.html)

缺点：
* 同步加载模式不适用于浏览器
* 不能非阻塞并行多个加载

3. ##### AMD
详情见我的博客 [AMD](https://gitxiangzhang.github.io/xiangzhang.github.io/2016/04/30/AMD%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD.html)

4. ##### CMD
5. ##### ES6module

----------------------------------
#### 期望的模块系统
1. 前端模块要在浏览器执行，所以他们需要增量加载到浏览器中。模块的传输和加载 我们首先能想到两种极端的方式，一种是把所有模块都打包到一个文件中只请求一次，
另一种是每个模块文件都单独请求，显而易见两种方式都不够完善，请求过多会启动变慢，一次请求全部，暂时用不到的模块也请求过来了，导致流量浪费
响应也会变慢。
我们所期望的一种模式是：按需进行懒加载，在实际用到某些模块的时候在进行增量跟新。

2. 可以兼容样式，图片，字体等众多类型模块资源。

如何做到我们期望的： 在编译阶段，对整个代码进行静态分析，分析出各个模块的类型和他们的依赖关系，然后将不同类型的模块提交给适配的加载器处理
比如一个用less 写的样式模块，可以先用less 加载器将他转换成 css模块，再通过css模块把他插入到页面的 style 标签中执行。webpack 就在这样的需求中
诞生。



----------------------------------
#### webpack
webpack 是一个模块打包器，他将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。

![webpack2]({{ site.baseurl }}/images/webpack2.jpg)

这里提一下webpack和grunt gulp 有什么不一样：

grunt 和 gulp 的工作方式是 ：Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。

![webpack1]({{ site.baseurl }}/images/webpack1.jpg)

Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。

----------------------------------
#### webpack特点
1. ##### 代码拆分

























>首先说，code splitting指什么。我们打包时通常会生成一个大的bundle.js(或者index,看你如何命名)文件，这样所有的模块都会打包到这个bundle.js文件中，
最终生成的文件往往比较大。code splitting就是指将文件分割为块(chunk)，webpack使我们可以定义一些分割点(split point)，根据这些分割点对文件进行分块，并实现按需加载。

1. 第三方类库单独打包。由于第三方类库的内容基本不会改变，可以将其与业务代码分离出来，这样就可以将类库代码缓存在客户端，减少请求。
2. 按需加载。webpack支持定义分割点，通过require.ensure进行按需加载。
3. 通用模块单独打包。我们代码中可能会有一些通用模块，比如弹窗、分页、通用的方法等等。其他业务代码模块常常会有引用这些通用模块。若按照2中做，则会造成通用模块重复打包。这时可以将通用模块单独打包出来。

----------------------------------
#### CommonsChunkPlugin打包第三方类库
>我们项目中常常会用到一些第三方的类库，比如jquery,bootstrap等。可以配置多入口来将第三方类库单独打包，如下：

webpack.config.js

{% highlight JavaScript %}
var webpack= require('webpack')

module.exports={
  entry: {
    app: './main.js',
    vendor: ['jquery'],
  },
  output: {
    filename: 'bundle.js'
  },
  plugins: [
    new webpack.optimize.CommonsChunkPlugin(/* chunkName= */'vendor', /* filename= */'vendor.js')
  ]
}

{% endhighlight %}

CommonsChunkPlugin提供两个参数，第一个参数为对应的chunk名（chunk指文件块，对应entry中的属性名），第二个参数为生成的文件名。

这个插件做了两件事：

1. 将vendor配置的模块（jquery,bootstrap）打包到vendor.js中。
2. 将main中存在的jquery, bootstrap模块从文件中移除。这样main中则只留下纯净的业务代码。

源码见webpack-demos demo13。

----------------------------------
#### require.ensure按需加载

以基于backbone的单页面应用为例，可以在router中进行配置实现按需加载，如下：

{% highlight JavaScript %}
router.js

var Router = Backbone.Router.extend({
    routes: {
        'a': 'a',
        'b': 'b'
    },

    a: function() {
        require.ensure(['./a'], (require) => {
            let a = require('./a');
            //do something
        })
    },

    b: function() {
        require.ensure(['./b'], (require) => {
            let b = require('./b');
            //do something
        })
    }
})
{% endhighlight %}

如上方式将打包出两个文件，a.js和b.js（当然名字会有所不同），且为按需加载。只有在访问a时，a.js才会被加载，b同理。但是这种做法存在两个问题：

1. 若路由分配不合理，会打包出很多很小的文件，每个文件或许只有几k，却多了很多网络请求，得不偿失。
2. 会造成通用模块的重复打包，比如a模块和b模块都引用了c模块，

对于问题一可以通过AggressiveMergingPlugin插件解决。

//在plugins中添加该插件：
plugins: [
    new webpack.optimize.AggressiveMergingPlugin()
]

对问题二可以用CommonsChunkPlugin打包通用模块解决。